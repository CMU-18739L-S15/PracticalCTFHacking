# Binary Exploitation

One of the first challenges in binary exploitation is using the UNIX command line.  While we assume basic UNIX experience, there are unique CTF-specific tasks often crop up. This is grab-bag of such tricks and tips.  We use the program named `ctf` to stand in for any CTF program.

## Python one-liners

Often you want to generate a specific string, e.g., a long string, a string with non-printable characters, etc.  We can use python one liners to solve such tasks.

The following command generates a 400 character string of A's.

```
$ python -c 'print "A"x400'
```

We can also use python to create strings based on hex encoding, such as a NOP sled where `0x90` is the x86 nop instruction:
```
$ python -c 'print "\x90"*400'
```

Be careful of endianness. For example, on x86 to encode the constant `0xdeadbeef`, you would do:
```
$ python -c 'print "\xef\xbe\xad\xde'
```
## Perl one liners

Some people prefer perl. Those people should fill in this part of the book.

## Shell Tricks

### Providing command-generated input
Suppose you want to provide a long input to a program. We can use our one-liners from above to generate the input, and use the modern shell feature of using `$(<cmd>)`, e.g.,

```
$ ctf $(python -c 'print "\x90"*400')
```

Note that `$(<cmd>)` is the modern method; you can also try your luck at using the older (and less easy to nest) backtick `` `<cmd>` `` approach to launch a shell, i.e.,:
```
$ ctf ` python -c 'print "\x90"*400' `
```
uses backticks and is equivalent to the above.

### cat trick for stdin
One problem you may have in stdin closes when you cat an input to a program.  For example, suppose you have a problem that already does `execve(/bin/sh, NULL, NULL)`, and the goal is to call this code, e.g.,
```

void foo()
{
  execve("/bin/sh", NULL, NULL);
}

code(){
  overflow...
}

(note to self: look for pipe variant)
```

You prepare a buffer overflow that calls `foo`, spawns the shell, but closes right away. The problem is stdin closed.

A trick is to use '-' to keep stdin open. Suppose your exploit string is in file `<file>`, then you can do:

```
$ cat <file> - | ./ctf
```

and type in yoru commands.

### Disable ASLR (sometimes) with ulimit -s unlimited

You probably know you can [disable ASLR system-wide](http://www.commandlinefu.com/commands/matching/disable-aslr/ZGlzYWJsZSBhc2xy/sort-by-votes) as root with:
```
# echo 0 > /proc/sys/kernel/randomize_va_space
```

What do you do if you're not root?  Suppose you have command line access to a binary, but it is protected with ASLR. One trick is to disable the maximum stack size limit, making it theoretically the maximum size.



On 32-bit systems, this will also disable the randomization of the mmap()-ing. According to [Hexcellencts](http://security.cs.pub.ro/hexcellents/wiki/kb/exploiting/home), it is because of the following code in arch/x86/mm/mmap.c:

```
static int mmap_is_legacy(void)
{
        if (current->personality & ADDR_COMPAT_LAYOUT)
                return 1;

        if (rlimit(RLIMIT_STACK) == RLIM_INFINITY)
                return 1;

        return sysctl_legacy_va_layout;
}
```
### Checking for binary protection

The [checksec.sh](http://www.trapkit.de/tools/checksec.sh) tool checks for NX, PIE, and other things of interest to exploitation.

## GDB tips and tricks.


### gdb -tui

Did you know gdb has a [text user interface](https://sourceware.org/gdb/onlinedocs/gdb/TUI.html)?  Try it -- you might like it.

```
 $ gdb -tui <program>
```

### Use PEDA

[PEDA](https://github.com/longld/peda) stands for Python Exploit Development Assistance for GDB. It puts gdb on steroids. It is also worth looking at the source to understand more about scripting in gdb.

When you run an application in PEDA, you'll notice (by default) a much more informative screen that includes the disassembly of the current instruction, status of registers, memory image, and so on.  It also has `checksec` to check for security options (similar to `checksec.sh`), tools for searching for ROP gadgetry, and a number of other useful tidbits.

### Software breakpoints

Software breakpoints work by dynamically inserting the software breakpoint, e.g., `INT 3` (0xcc) on x86.  One anti-debugging trick is for a process to look for [software breakpoints in its process image](http://www.stonedcoder.org/~kd/lib/14-61-1-PB.pdf).

If you find such checks, one solution is to nop them out. Another is to use hardware breakpoints.

### Hardware breakpoints

In gdb, you can use the [`hbreak` command](https://sourceware.org/gdb/onlinedocs/gdb/Set-Breaks.html) to set a hardware-assisted breakpoint.  As mentioned above, hardware breakpoints are useful for circumventing software breakpoint anti-debugging techniques.

Some of us have had difficulty using `hbreak` directly after starting a running binary.   One workaround we have found is to first set a software breakpoint, delete it, and then set a hardware breakpoint.

### Python and gdb interfaces
subclass breakpoint.


## TODO

### Ropgadget tool

### mona.py

### metasploit framework. msfinput, msfelfscan



### ropshell.com


